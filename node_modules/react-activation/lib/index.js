'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _flatten = _interopDefault(require('szfe-tools/lib/flatten'));
var _get = _interopDefault(require('szfe-tools/lib/get'));
var React = require('react');
var React__default = _interopDefault(React);
var createContext$1 = _interopDefault(require('create-react-context'));
var _run = _interopDefault(require('szfe-tools/lib/run'));
var _nextTick = _interopDefault(require('szfe-tools/lib/nextTick'));
var _isFunction = _interopDefault(require('szfe-tools/lib/isFunction'));
var _isUndefined = _interopDefault(require('szfe-tools/lib/isUndefined'));
var _isObject = _interopDefault(require('szfe-tools/lib/isObject'));
var hoistStatics = _interopDefault(require('hoist-non-react-statics'));
var _value = _interopDefault(require('szfe-tools/lib/value'));
var _debounce = _interopDefault(require('szfe-tools/lib/debounce'));
var _isArray = _interopDefault(require('szfe-tools/lib/isArray'));
var _globalThis = _interopDefault(require('szfe-tools/lib/globalThis'));
var NodeKey = _interopDefault(require('react-node-key'));
var _isExist = _interopDefault(require('szfe-tools/lib/isExist'));

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  }
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

// 值类型判断 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
var isRegExp = function isRegExp(val) {
  return val instanceof RegExp;
}; // 值类型判断 -------------------------------------------------------------

var aliveScopeContext = createContext$1();
var AliveScopeProvider = aliveScopeContext.Provider,
    AliveScopeConsumer = aliveScopeContext.Consumer; // KeepAlive 组件的上下文，实现缓存生命周期功能
var aliveNodeContext = createContext$1();
var AliveNodeProvider = aliveNodeContext.Provider,
    AliveNodeConsumer = aliveNodeContext.Consumer;

var _filehash = "jUqy";
var fixedContext = [];
var updateListenerCache = new Map();
function fixContext(ctx) {
  fixedContext.push(ctx);
}
var createContext = function createContext() {
  var ctx = createContext$1.apply(void 0, arguments);
  fixContext(ctx);
  return ctx;
}; // 递归重建上下文 Provider

var ProviderBridge =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(ProviderBridge, _PureComponent);

  function ProviderBridge(props) {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, ProviderBridge);

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ProviderBridge)).call.apply(_getPrototypeOf2, [this, props].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "unmount", null);

    var ctxValues = props.value;

    if (ctxValues.length === 0) {
      _this.state = {
        ctxValue: null
      };
      return _possibleConstructorReturn(_this);
    }

    var _ctxValues = _slicedToArray(ctxValues, 1),
        _ctxValues$ = _ctxValues[0],
        ctx = _ctxValues$.ctx,
        value = _ctxValues$.value,
        onUpdate = _ctxValues$.onUpdate;

    _this.state = {
      ctxValue: value
    };
    _this.unmount = onUpdate(function (value) {
      _this.setState({
        ctxValue: value
      });
    });
    return _this;
  }

  _createClass(ProviderBridge, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      _run(this.unmount);
    } // componentDidCatch(error) {
    //   console.error('ProviderBridge Error', error)
    // }

  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          ctxValues = _this$props.value,
          children = _this$props.children;

      if (ctxValues.length === 0) {
        return children;
      }

      var ctxValue = this.state.ctxValue;

      var _ctxValues2 = _toArray(ctxValues),
          ctx = _ctxValues2[0].ctx,
          restValues = _ctxValues2.slice(1);

      var Provider = ctx.Provider;
      var nextChildren = !_isUndefined(ctxValue) ? React__default.createElement(Provider, {
        value: ctxValue,
        _nk: "".concat(_filehash, "11")
      }, children) : children; // 递归 ProviderBridge 修复多个上下文
      // 此处未考虑待修复上下文顺序问题，按先来后到顺序处理，但理论上不应存在顺序问题

      return restValues.length > 0 ? React__default.createElement(ProviderBridge, {
        value: restValues,
        _nk: "".concat(_filehash, "21")
      }, nextChildren) : nextChildren;
    }
  }]);

  return ProviderBridge;
}(React.PureComponent); // 在 KeepAlive 位置使用待修复上下文的 Consumer 探测可能存在的上下文关系
// 若成功捕获上下文则保存其内容，用以后续 Keeper 中上下文的重建

var ConsumerWrapper =
/*#__PURE__*/
function (_PureComponent2) {
  _inherits(ConsumerWrapper, _PureComponent2);

  function ConsumerWrapper(props) {
    var _getPrototypeOf3;

    var _this2;

    _classCallCheck(this, ConsumerWrapper);

    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    _this2 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(ConsumerWrapper)).call.apply(_getPrototypeOf3, [this, props].concat(args)));

    _defineProperty(_assertThisInitialized(_this2), "updateListener", null);

    _defineProperty(_assertThisInitialized(_this2), "ctxInfo", null);

    var value = props.value,
        ctx = props.ctx,
        id = props.id;

    if (_isUndefined(value)) {
      return _possibleConstructorReturn(_this2);
    } // 因 Consumer 探测器存在于 KeepAlive 外层故会随着 KeepAlive 卸载
    // componentWillUnmount 中保留了已生成的更新监听器
    // 此处重新挂载后恢复与对应 Keeper 中 ProviderBridge 的联系


    _this2.updateListener = _get(updateListenerCache.get(ctx), id, new Map());
    _this2.ctxInfo = {
      ctx: ctx,
      value: value,
      // 注册上下文更新的监听，保证上下文更新时 Keeper 中 ProviderBridge 内容的同步
      onUpdate: function onUpdate(updator) {
        _this2.updateListener.set(updator, updator); // 返回更新监听器的注销方法


        return function () {
          return _this2.updateListener["delete"](updator);
        };
      }
    };
    return _this2;
  }

  _createClass(ConsumerWrapper, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this$props2 = this.props,
          value = _this$props2.value,
          ctx = _this$props2.ctx,
          id = _this$props2.id;

      if (_isUndefined(value)) {
        return;
      } // 因 Consumer 探测器存在于 KeepAlive 外层故会随着 KeepAlive 卸载
      // 此处保留其中已生成的更新监听器，用以在重新挂载后保持与对应 Keeper 中 ProviderBridge 的联系


      updateListenerCache.set(ctx, _objectSpread2({}, _get(updateListenerCache.get(ctx), undefined, {}), _defineProperty({}, id, this.updateListener)));
    } // 利用 shouldComponentUpdate 尽早将上下文更新的咨询通知到对应 Keeper 中 ProviderBridge
    // TODO: 改用 componentWillReceiveProps 更早地进行更新，需注意与 getDerivedStateFromProps 新生命周期的兼容及可能存在的死循环问题

  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(_ref) {
      var value = _ref.value;
      var prevValue = this.props.prevValue;
      var shouldUpdate = prevValue !== value;

      if (shouldUpdate) {
        _run(this.updateListener, 'forEach', function (fn) {
          return fn(value);
        });
      }

      return shouldUpdate;
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props3 = this.props,
          value = _this$props3.value,
          renderWrapper = _this$props3.renderWrapper,
          renderContent = _this$props3.renderContent,
          id = _this$props3.id;
      return renderWrapper(function (ctx$$) {
        return renderContent(_isUndefined(value) ? ctx$$ : [].concat(_toConsumableArray(ctx$$), [_this3.ctxInfo]));
      });
    }
  }]);

  return ConsumerWrapper;
}(React.PureComponent); // 对 ConsumerWrapper 的递归结构，会在 devtool 中生成较深的嵌套结构，可用 hooks 消除嵌套结构


function RecursiveConsumerBridge(_ref2) {
  var renderChildren = _ref2.children,
      id = _ref2.id;
  var renderWrapper = fixedContext.reduce(function (render, ctx) {
    var Consumer = ctx.Consumer;

    var renderWrapper = function renderWrapper(renderContent) {
      return React__default.createElement(Consumer, {
        _nk: "".concat(_filehash, "31")
      }, function (value) {
        return React__default.createElement(ConsumerWrapper, _extends({
          value: value,
          ctx: ctx,
          renderWrapper: render,
          renderContent: renderContent,
          id: id
        }, {
          _nk: "".concat(_filehash, "41")
        }));
      });
    };

    return renderWrapper;
  }, function (renderContent) {
    return renderContent([]);
  });
  return renderWrapper(renderChildren);
} // 若支持 Hooks，就不需要递归了，相关实现解释可参考 ConsumerWrapper


function HooksConsumerBridge(_ref3) {
  var renderChildren = _ref3.children,
      id = _ref3.id;
  var context$$ = fixedContext.map(function (ctx) {
    var value = React.useContext(ctx);
    var prevValueRef = React.useRef(value);

    var _useRef = React.useRef(_get(updateListenerCache.get(ctx), id, new Map())),
        updateListener = _useRef.current; // 尽可能早地进行更新


    if (prevValueRef.current !== value) {
      _nextTick(function () {
        return _run(updateListener, 'forEach', function (fn) {
          return fn(value);
        });
      });
    }

    prevValueRef.current = value;
    React.useEffect(function () {
      return function () {
        if (_isUndefined(value)) {
          return;
        }

        updateListenerCache.set(ctx, _objectSpread2({}, _get(updateListenerCache.get(ctx), undefined, {}), _defineProperty({}, id, updateListener)));
      };
    }, []);
    return {
      ctx: ctx,
      value: value,
      onUpdate: function onUpdate(fn) {
        updateListener.set(fn, fn);
        return function () {
          return updateListener["delete"](fn);
        };
      }
    };
  }).filter(function (_ref4) {
    var value = _ref4.value;
    return !_isUndefined(value);
  });
  return renderChildren(context$$);
}

var ConsumerBridge = [React.useContext, React.useRef, React.useEffect].every(_isFunction) ? HooksConsumerBridge : RecursiveConsumerBridge;

var _temp;
var _filehash$1 = "46lG";
var isSupported = _isFunction(React.lazy) && !_isUndefined(React.Suspense);

var SusNotSupported = function SusNotSupported(_ref) {
  var children = _ref.children;
  return _run(children);
};

var Lazy = isSupported ? React.lazy(function () {
  return new Promise(function () {
    return null;
  });
}) : function () {
  return null;
};

var FallbackListener =
/*#__PURE__*/
function (_Component) {
  _inherits(FallbackListener, _Component);

  function FallbackListener() {
    _classCallCheck(this, FallbackListener);

    return _possibleConstructorReturn(this, _getPrototypeOf(FallbackListener).apply(this, arguments));
  }

  _createClass(FallbackListener, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      _run(this.props, 'onStart');
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      _run(this.props, 'onEnd');
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);

  return FallbackListener;
}(React.Component);

function SuspenseBridge(_ref2) {
  var children = _ref2.children,
      sus$$ = _ref2.sus$$;
  return (// 捕获 Keeper 内部可能存在的 lazy，并触发对应 KeepAlive 位置上的 LazyBridge
    React__default.createElement(React.Suspense, {
      fallback: React__default.createElement(FallbackListener, {
        onStart: sus$$.onSuspenseStart,
        onEnd: sus$$.onSuspenseEnd,
        _nk: "".concat(_filehash$1, "21")
      }),
      _nk: "".concat(_filehash$1, "11")
    }, children)
  );
}

var LazyBridge = isSupported ? (_temp =
/*#__PURE__*/
function (_Component2) {
  _inherits(LazyBridge, _Component2);

  function LazyBridge() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, LazyBridge);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LazyBridge)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "state", {
      suspense: false
    });

    _defineProperty(_assertThisInitialized(_this), "onSuspenseStart", function () {
      _this.setState({
        suspense: true
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onSuspenseEnd", function () {
      _this.setState({
        suspense: false
      });
    });

    _defineProperty(_assertThisInitialized(_this), "sus$$", {
      onSuspenseStart: _this.onSuspenseStart,
      onSuspenseEnd: _this.onSuspenseEnd
    });

    return _this;
  }

  _createClass(LazyBridge, [{
    key: "render",
    value: function render() {
      var children = this.props.children;
      return React__default.createElement(React.Fragment, null, _run(children, undefined, this.sus$$), this.state.suspense && React__default.createElement(Lazy, {
        _nk: "".concat(_filehash$1, "31")
      }));
    }
  }]);

  return LazyBridge;
}(React.Component), _temp) : SusNotSupported;
var SuspenseBridge$1 = isSupported ? SuspenseBridge : SusNotSupported;

var ErrorBoundaryBridge =
/*#__PURE__*/
function (_Component) {
  _inherits(ErrorBoundaryBridge, _Component);

  function ErrorBoundaryBridge() {
    _classCallCheck(this, ErrorBoundaryBridge);

    return _possibleConstructorReturn(this, _getPrototypeOf(ErrorBoundaryBridge).apply(this, arguments));
  }

  _createClass(ErrorBoundaryBridge, [{
    key: "componentDidCatch",
    // Error Boundary 透传至对应 KeepAlive 实例位置
    value: function componentDidCatch(error) {
      var throwError = this.props.error$$;

      _run(throwError, undefined, error, function () {
        _run(throwError, undefined, null);
      });
    }
  }, {
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);

  return ErrorBoundaryBridge;
}(React.Component);

_defineProperty(ErrorBoundaryBridge, "getDerivedStateFromError", function () {
  return null;
});
var ErrorThrower =
/*#__PURE__*/
function (_Component2) {
  _inherits(ErrorThrower, _Component2);

  function ErrorThrower() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, ErrorThrower);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ErrorThrower)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "state", {
      error: null
    });

    _defineProperty(_assertThisInitialized(_this), "throwError", function (error, cb) {
      return _this.setState({
        error: error
      }, cb);
    });

    return _this;
  }

  _createClass(ErrorThrower, [{
    key: "render",
    value: function render() {
      if (this.state.error) {
        throw this.state.error;
      }

      return _run(this.props.children, undefined, this.throwError);
    }
  }]);

  return ErrorThrower;
}(React.Component);

var _filehash$2 = "lajT";
function Bridge(_ref) {
  var id = _ref.id,
      children = _ref.children,
      bridgeProps = _ref.bridgeProps;
  var sus$$ = bridgeProps.sus$$,
      ctx$$ = bridgeProps.ctx$$,
      error$$ = bridgeProps.error$$;
  return (
    /* 由内向外透传 componentDidCatch 捕获的 error */
    React__default.createElement(ErrorBoundaryBridge, {
      error$$: error$$,
      _nk: "".concat(_filehash$2, "11")
    }, React__default.createElement(SuspenseBridge$1, {
      sus$$: sus$$,
      _nk: "".concat(_filehash$2, "21")
    }, React__default.createElement(ProviderBridge, {
      id: id,
      value: ctx$$,
      _nk: "".concat(_filehash$2, "31")
    }, children)))
  );
} // 用于 KeepAlive 中，实现 KeepAlive 向外或向内的桥接代理

function Acceptor(_ref2) {
  var id = _ref2.id,
      children = _ref2.children;
  return (
    /* 由内向外透传 componentDidCatch 捕获的 error */
    React__default.createElement(ErrorThrower, {
      _nk: "".concat(_filehash$2, "41")
    }, function (error$$) {
      return (
        /* 由内向外透传 lazy 行为 */
        React__default.createElement(LazyBridge, {
          _nk: "".concat(_filehash$2, "51")
        }, function (sus$$) {
          return (
            /* 由外向内透传可能被捕获的 Provider 数据 */
            React__default.createElement(ConsumerBridge, {
              id: id,
              _nk: "".concat(_filehash$2, "61")
            }, function (ctx$$) {
              return _run(children, undefined, {
                bridgeProps: {
                  sus$$: sus$$,
                  ctx$$: ctx$$,
                  error$$: error$$
                }
              });
            })
          );
        })
      );
    })
  );
}

var _filehash$3 = "XKTv";
var LIFECYCLE_ACTIVATE = 'componentDidActivate';
var LIFECYCLE_UNACTIVATE = 'componentWillUnactivate';
var withActivation = function withActivation(WrappedComponent) {
  var HOC =
  /*#__PURE__*/
  function (_Component) {
    _inherits(HOC, _Component);

    function HOC() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, HOC);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(HOC)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _defineProperty(_assertThisInitialized(_this), "drop", null);

      return _this;
    }

    _createClass(HOC, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        _run(this.drop);
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        var _this$props = this.props,
            forwardedRef = _this$props.forwardedRef,
            props = _objectWithoutProperties(_this$props, ["forwardedRef"]);

        return React__default.createElement(AliveNodeConsumer, {
          _nk: "".concat(_filehash$3, "11")
        }, function () {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              attach = _ref.attach;

          return React__default.createElement(WrappedComponent, _extends({
            ref: function ref(_ref2) {
              if ([LIFECYCLE_ACTIVATE, LIFECYCLE_UNACTIVATE].every(function (lifecycleName) {
                return !_isFunction(_get(_ref2, lifecycleName));
              })) {
                return;
              }

              _this2.drop = _run(attach, undefined, _ref2); // 以下保持 ref 功能

              if (_isUndefined(forwardedRef)) {
                return;
              }

              if (_isObject(forwardedRef) && 'current' in forwardedRef) {
                forwardedRef.current = _ref2;
                return;
              }

              _run(forwardedRef, undefined, _ref2);
            }
          }, props, {
            _nk: "".concat(_filehash$3, "21")
          }));
        });
      }
    }]);

    return HOC;
  }(React.Component); // 由于 KeepAlive 内组件渲染与实际内容落后一个节拍
  // 将导致真实节点的 componentDidMount 无法及时获取到 KeepAlive 中内容的 ref 值
  // 此处对使用了 withActivation HOC 的组件 componentDidMount 做 nextTick 延时处理
  // 修复上述问题


  if (_isFunction(WrappedComponent.prototype.componentDidMount)) {
    WrappedComponent.prototype._componentDidMount = WrappedComponent.prototype.componentDidMount;

    WrappedComponent.prototype.componentDidMount = function componentDidMount() {
      var _this3 = this;

      _nextTick(function () {
        return WrappedComponent.prototype._componentDidMount.call(_this3);
      });
    };
  }

  if (_isFunction(React.forwardRef)) {
    var ForwardedRefHOC = React.forwardRef(function (props, ref) {
      return React__default.createElement(HOC, _extends({}, props, {
        forwardedRef: ref,
        _nk: "".concat(_filehash$3, "31")
      }));
    });
    return hoistStatics(ForwardedRefHOC, WrappedComponent);
  } else {
    return hoistStatics(HOC, WrappedComponent);
  }
};

var useActivation = function useActivation(funcName, func) {
  // 兼容性判断
  if ([React.useRef, React.useContext, React.useEffect].some(function (fn) {
    return !_isFunction(fn);
  })) {
    return;
  }

  var ctxValue = React.useContext(aliveNodeContext); // 未处于 KeepAlive 中

  if (!ctxValue) {
    return;
  }

  var _useRef = React.useRef({}),
      ref = _useRef.current;

  var attach = ctxValue.attach;
  ref[funcName] = func;
  ref.drop = attach(ref);
  React.useEffect(function () {
    return function () {
      return _run(ref.drop);
    };
  }, []);
};

var useActivate = useActivation.bind(null, LIFECYCLE_ACTIVATE);
var useUnactivate = useActivation.bind(null, LIFECYCLE_UNACTIVATE);

var _filehash$4 = "bNyU";

var Keeper =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(Keeper, _PureComponent);

  function Keeper(props) {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, Keeper);

    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Keeper)).call.apply(_getPrototypeOf2, [this, props].concat(rest)));

    _defineProperty(_assertThisInitialized(_this), "listeners", new Map());

    _defineProperty(_assertThisInitialized(_this), "wrapper", null);

    _defineProperty(_assertThisInitialized(_this), "attach", function (ref) {
      var _listeners$set;

      var listeners = _this.listeners;

      if (!ref) {
        return function () {
          return null;
        };
      }

      if (ref.isKeepAlive) {
        _nextTick(function () {
          var _this$props = _this.props,
              id = _this$props.id,
              store = _this$props.store;
          var cache = store.get(id);
          cache.aliveNodesId = new Set([].concat(_toConsumableArray(cache.aliveNodesId), [ref.id]));
        });
      }

      listeners.set(ref, (_listeners$set = {}, _defineProperty(_listeners$set, LIFECYCLE_ACTIVATE, function () {
        return _run(ref, LIFECYCLE_ACTIVATE);
      }), _defineProperty(_listeners$set, LIFECYCLE_UNACTIVATE, function () {
        return _run(ref, LIFECYCLE_UNACTIVATE);
      }), _listeners$set)); // 返回 listenerRemover 用以在对应组件卸载时解除监听

      return function () {
        listeners["delete"](ref);
      };
    });

    _defineProperty(_assertThisInitialized(_this), "contextValue", {
      id: _this.props.id,
      attach: _this.attach
    });

    _defineProperty(_assertThisInitialized(_this), "refresh", function (cb) {
      return _this.setState({
        key: Math.random()
      }, cb);
    });

    _this.state = {
      children: props.children,
      bridgeProps: props.bridgeProps,
      key: Math.random()
    };
    return _this;
  }

  _createClass(Keeper, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this,
          _store$set;

      var _this$props2 = this.props,
          store = _this$props2.store,
          id = _this$props2.id;
      var listeners = this.listeners;
      var node = this.wrapper; // 已存在检测，防止意外现象

      if (store.has(id)) {
        return;
      }

      store.set(id, (_store$set = {
        listeners: listeners,
        aliveNodesId: [],
        inited: false,
        cached: false,
        wrapper: node,
        nodes: _toConsumableArray(node.children)
      }, _defineProperty(_store$set, LIFECYCLE_ACTIVATE, function () {
        return _this2[LIFECYCLE_ACTIVATE]();
      }), _defineProperty(_store$set, LIFECYCLE_UNACTIVATE, function () {
        return _this2[LIFECYCLE_UNACTIVATE]();
      }), _store$set));
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this$props3 = this.props,
          store = _this$props3.store,
          keepers = _this$props3.keepers,
          id = _this$props3.id; // 卸载前尝试归位 DOM 节点

      try {
        var cache = store.get(id);
        cache.nodes.forEach(function (node) {
          cache.wrapper.appendChild(node);
        });
      } catch (error) {// console.error(error) // do nothing
      }

      store["delete"](id);
      keepers["delete"](id);
    }
  }, {
    key: LIFECYCLE_ACTIVATE,
    value: function value() {
      this.listeners.forEach(function (listener) {
        return _run(listener, [LIFECYCLE_ACTIVATE]);
      });
    }
  }, {
    key: LIFECYCLE_UNACTIVATE,
    value: function value() {
      var listeners = _toConsumableArray(this.listeners);

      listeners.reverse().forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            listener = _ref2[1];

        return _run(listener, [LIFECYCLE_UNACTIVATE]);
      });
    } // // 原先打算更新过程中先重置 dom 节点状态，更新后恢复 dom 节点
    // // 但考虑到性能消耗可能过大，且可能因 dom 操作时机引发其他 react 渲染问题，故不使用
    // // 对应 KeepAlive 处 update 也注释起来不使用
    // // 组件更新后，更新 DOM 节点列表状态
    // componentDidUpdate() {
    //   const { store, id } = this.props
    //   const node = this.wrapper
    //   if (get(node, 'children.length') > 0) {
    //     store[id].nodes = [...node.children]
    //   }
    //   console.log(store[id].nodes)
    // }
    // 生命周期绑定

  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var _this$props4 = this.props,
          id = _this$props4.id,
          props = _objectWithoutProperties(_this$props4, ["id"]);

      var _this$state = this.state,
          children = _this$state.children,
          bridgeProps = _this$state.bridgeProps,
          key = _this$state.key;
      return React__default.createElement("div", {
        ref: function ref(node) {
          _this3.wrapper = node;
        },
        _nk: "".concat(_filehash$4, "11")
      }, React__default.createElement("div", {
        key: "keeper-container",
        className: "ka-content"
      }, React__default.createElement(Bridge, {
        id: id,
        bridgeProps: bridgeProps,
        _nk: "".concat(_filehash$4, "21")
      }, React__default.createElement(AliveNodeProvider, {
        value: this.contextValue,
        _nk: "".concat(_filehash$4, "31")
      }, React__default.cloneElement(children, {
        key: "".concat(children.key, ":").concat(key)
      })))));
    }
  }]);

  return Keeper;
}(React.PureComponent);

var _filehash$5 = "UVSV";
var HANDLE_TYPE_DROP = 'drop';
var HANDLE_TYPE_REFRESH = 'refresh';

var AliveScope =
/*#__PURE__*/
function (_Component) {
  _inherits(AliveScope, _Component);

  function AliveScope() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, AliveScope);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AliveScope)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "store", new Map());

    _defineProperty(_assertThisInitialized(_this), "nodes", new Map());

    _defineProperty(_assertThisInitialized(_this), "keepers", new Map());

    _defineProperty(_assertThisInitialized(_this), "update", function (id, params) {
      return new Promise(function (resolve) {
        var keeper = _this.keepers.get(id);

        var isNew = !keeper;
        var now = Date.now();
        var node = _this.nodes.get(id) || null;

        _this.nodes.set(id, _objectSpread2({
          id: id,
          createTime: now,
          updateTime: now
        }, node, {}, params));

        if (isNew) {
          _this.helpers = _objectSpread2({}, _this.helpers);

          _this.forceUpdate(resolve);
        } else {
          var children = params.children,
              bridgeProps = params.bridgeProps;
          keeper.setState({
            children: children,
            bridgeProps: bridgeProps
          }, resolve);
        }
      });
    });

    _defineProperty(_assertThisInitialized(_this), "keep", function (id, params) {
      return new Promise(function (resolve) {
        _this.update(id, _objectSpread2({
          id: id
        }, params)).then(function () {
          resolve(_this.store.get(id));
        });
      });
    });

    _defineProperty(_assertThisInitialized(_this), "getCachingNodesByName", function (name) {
      return _this.getCachingNodes().filter(function (node) {
        return isRegExp(name) ? name.test(node.name) : node.name === name;
      });
    });

    _defineProperty(_assertThisInitialized(_this), "getScopeIds", function (ids) {
      // 递归采集 scope alive nodes id
      var getCachingNodesId = function getCachingNodesId(id) {
        var aliveNodesId = _get(_this.getCache(id), 'aliveNodesId', []);

        if (aliveNodesId.size > 0) {
          return [id, _toConsumableArray(aliveNodesId).map(getCachingNodesId)];
        }

        return [id].concat(_toConsumableArray(aliveNodesId));
      };

      return _flatten(ids.map(function (id) {
        return getCachingNodesId(id);
      }));
    });

    _defineProperty(_assertThisInitialized(_this), "dropById", function (id) {
      return _this.handleNodes([id], HANDLE_TYPE_DROP);
    });

    _defineProperty(_assertThisInitialized(_this), "dropScopeByIds", function (ids) {
      return _this.handleNodes(_this.getScopeIds(ids), HANDLE_TYPE_DROP);
    });

    _defineProperty(_assertThisInitialized(_this), "drop", function (name) {
      return _this.handleNodes(_this.getCachingNodesByName(name).map(function (node) {
        return node.id;
      }), HANDLE_TYPE_DROP);
    });

    _defineProperty(_assertThisInitialized(_this), "dropScope", function (name) {
      return _this.dropScopeByIds(_this.getCachingNodesByName(name).map(function (_ref) {
        var id = _ref.id;
        return id;
      }));
    });

    _defineProperty(_assertThisInitialized(_this), "refreshById", function (id) {
      return _this.handleNodes([id], HANDLE_TYPE_REFRESH);
    });

    _defineProperty(_assertThisInitialized(_this), "refreshScopeByIds", function (ids) {
      return _this.handleNodes(_this.getScopeIds(ids), HANDLE_TYPE_REFRESH);
    });

    _defineProperty(_assertThisInitialized(_this), "refresh", function (name) {
      return _this.handleNodes(_this.getCachingNodesByName(name).map(function (node) {
        return node.id;
      }), HANDLE_TYPE_REFRESH);
    });

    _defineProperty(_assertThisInitialized(_this), "refreshScope", function (name) {
      return _this.refreshScopeByIds(_this.getCachingNodesByName(name).map(function (_ref2) {
        var id = _ref2.id;
        return id;
      }));
    });

    _defineProperty(_assertThisInitialized(_this), "handleNodes", function (nodesId) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : HANDLE_TYPE_DROP;
      return new Promise(function (resolve) {
        var willRefreshKeepers = [];
        var willDropNodes = [];
        nodesId.forEach(function (id) {
          var cache = _this.store.get(id);

          if (!cache) {
            return;
          }

          var canRefresh = type === HANDLE_TYPE_REFRESH && !_get(cache, 'cached');

          var canDrop = type === HANDLE_TYPE_DROP && _get(cache, 'cached') || _get(cache, 'willDrop');

          if (canDrop) {
            // 用在多层 KeepAlive 同时触发 drop 时，避免触发深层 KeepAlive 节点的缓存生命周期
            cache.willDrop = true;

            _this.nodes["delete"](id);

            willDropNodes.push(id);
          }

          if (canRefresh) {
            var keeper = _this.keepers.get(id);

            willRefreshKeepers.push(keeper);
          }
        });
        Promise.all([willDropNodes.length === 0 ? Promise.resolve(false) : new Promise(function (resolve) {
          _this.helpers = _objectSpread2({}, _this.helpers);

          _this.forceUpdate(function () {
            return resolve(true);
          });
        }), willRefreshKeepers.length === 0 ? Promise.resolve(false) : Promise.all(willRefreshKeepers.map(function (keeper) {
          return new Promise(function (resolve) {
            return keeper.refresh(resolve);
          });
        }))]).then(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              dropSuccessfully = _ref4[0],
              refreshSuccessfully = _ref4[1];

          return resolve(Boolean(dropSuccessfully || refreshSuccessfully));
        });
      });
    });

    _defineProperty(_assertThisInitialized(_this), "clear", function () {
      return _this.handleNodes(_this.getCachingNodes().map(function (_ref5) {
        var id = _ref5.id;
        return id;
      }));
    });

    _defineProperty(_assertThisInitialized(_this), "getCache", function (id) {
      return _this.store.get(id);
    });

    _defineProperty(_assertThisInitialized(_this), "getNode", function (id) {
      return _this.nodes.get(id);
    });

    _defineProperty(_assertThisInitialized(_this), "getCachingNodes", function () {
      return _toConsumableArray(_this.nodes.values());
    });

    _defineProperty(_assertThisInitialized(_this), "helpers", {
      keep: _this.keep,
      update: _this.update,
      drop: _this.drop,
      dropScope: _this.dropScope,
      dropById: _this.dropById,
      dropScopeByIds: _this.dropScopeByIds,
      refresh: _this.refresh,
      refreshScope: _this.refreshScope,
      refreshById: _this.refreshById,
      refreshScopeByIds: _this.refreshScopeByIds,
      getScopeIds: _this.getScopeIds,
      clear: _this.clear,
      getCache: _this.getCache,
      getNode: _this.getNode,
      getCachingNodes: _this.getCachingNodes
    });

    return _this;
  }

  _createClass(AliveScope, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      var children = this.props.children;
      return React__default.createElement(AliveScopeProvider, {
        value: this.helpers,
        _nk: "".concat(_filehash$5, "11")
      }, children, React__default.createElement("div", {
        style: {
          display: 'none'
        },
        _nk: "".concat(_filehash$5, "21")
      }, _toConsumableArray(this.nodes.values()).map(function (_ref6) {
        var children = _ref6.children,
            props = _objectWithoutProperties(_ref6, ["children"]);

        return React__default.createElement(Keeper, _extends({
          key: props.id
        }, props, {
          store: _this2.store,
          keepers: _this2.keepers,
          ref: function ref(keeper) {
            _this2.keepers.set(props.id, keeper);
          },
          _nk: "iAr".concat(_filehash$5, "31")
        }), children);
      })));
    }
  }]);

  return AliveScope;
}(React.Component);

var _filehash$6 = "X7Aa";

function controllerCherryPick(controller) {
  var drop = controller.drop,
      dropScope = controller.dropScope,
      refresh = controller.refresh,
      refreshScope = controller.refreshScope,
      clear = controller.clear,
      getCachingNodes = controller.getCachingNodes;
  return {
    drop: drop,
    dropScope: dropScope,
    refresh: refresh,
    refreshScope: refreshScope,
    clear: clear,
    getCachingNodes: getCachingNodes
  };
}

var expandKeepAlive = function expandKeepAlive(KeepAlive) {
  var renderContent = function renderContent(_ref) {
    var idPrefix = _ref.idPrefix,
        helpers = _ref.helpers,
        props = _ref.props;

    var isOutsideAliveScope = _isUndefined(helpers);

    if (isOutsideAliveScope) {
      console.error('You should not use <KeepAlive /> outside a <AliveScope>');
    }

    return isOutsideAliveScope ? _get(props, 'children', null) : React__default.createElement(NodeKey, {
      prefix: idPrefix,
      key: props._nk,
      _nk: "".concat(_filehash$6, "11")
    }, function (id) {
      return React__default.createElement(Acceptor, {
        id: id,
        _nk: "".concat(_filehash$6, "21")
      }, function (bridgeProps) {
        return React__default.createElement(KeepAlive, _extends({
          key: id
        }, props, bridgeProps, {
          id: id,
          _helpers: helpers,
          _nk: "".concat(_filehash$6, "31")
        }));
      });
    });
  };

  var HookExpand = function HookExpand(_ref2) {
    var idPrefix = _ref2.id,
        props = _objectWithoutProperties(_ref2, ["id"]);

    return renderContent({
      idPrefix: idPrefix,
      helpers: React.useContext(aliveScopeContext),
      props: props
    });
  };

  var WithExpand = function WithExpand(_ref3) {
    var idPrefix = _ref3.id,
        props = _objectWithoutProperties(_ref3, ["id"]);

    return React__default.createElement(AliveScopeConsumer, {
      _nk: "".concat(_filehash$6, "41")
    }, function (helpers) {
      return renderContent({
        idPrefix: idPrefix,
        helpers: helpers,
        props: props
      });
    });
  };

  return _isFunction(React.useContext) ? HookExpand : WithExpand;
};

var withAliveScope = function withAliveScope(WrappedComponent) {
  var renderContent = function renderContent(_ref4) {
    var helpers = _ref4.helpers,
        props = _ref4.props,
        forwardedRef = _ref4.forwardedRef;
    return React__default.createElement(WrappedComponent, _extends({}, props, helpers, {
      ref: forwardedRef,
      _nk: "".concat(_filehash$6, "51")
    }));
  };

  var HookScope = function HookScope(_ref5) {
    var forwardedRef = _ref5.forwardedRef,
        props = _objectWithoutProperties(_ref5, ["forwardedRef"]);

    return renderContent({
      helpers: controllerCherryPick(React.useContext(aliveScopeContext) || {}),
      props: props,
      forwardedRef: forwardedRef
    });
  };

  var WithScope = function WithScope(_ref6) {
    var forwardedRef = _ref6.forwardedRef,
        props = _objectWithoutProperties(_ref6, ["forwardedRef"]);

    return React__default.createElement(AliveScopeConsumer, {
      _nk: "".concat(_filehash$6, "42")
    }, function () {
      var controller = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return renderContent({
        helpers: controllerCherryPick(controller),
        props: props,
        forwardedRef: forwardedRef
      });
    });
  };

  var HOCWithAliveScope = _isFunction(React.useContext) ? HookScope : WithScope;

  if (_isFunction(React.forwardRef)) {
    var ForwardedRefHOC = React.forwardRef(function (props, ref) {
      return React__default.createElement(HOCWithAliveScope, _extends({}, props, {
        forwardedRef: ref,
        _nk: "".concat(_filehash$6, "61")
      }));
    });
    return hoistStatics(ForwardedRefHOC, WrappedComponent);
  } else {
    return hoistStatics(HOCWithAliveScope, WrappedComponent);
  }
};

var useAliveController = function useAliveController() {
  if (!_isFunction(React.useContext)) {
    return {};
  }

  var ctxValue = React.useContext(aliveScopeContext);

  if (!ctxValue) {
    return {};
  }

  return controllerCherryPick(ctxValue);
};

function isScrollableNode() {
  var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (!_isExist(node)) {
    return false;
  }

  return node.scrollWidth > node.clientWidth || node.scrollHeight > node.clientHeight;
}

function getScrollableNodes(from) {
  if (!_isFunction(_get(_globalThis, 'document.querySelectorAll'))) {
    return [];
  }

  return [].concat(_toConsumableArray(_value(_run(from, 'querySelectorAll', '*'), [])), [from]).filter(isScrollableNode);
}

function saveScrollPosition(from) {
  var nodes = _toConsumableArray(new Set(_toConsumableArray(_flatten(from.map(getScrollableNodes)))));

  var saver = nodes.map(function (node) {
    return [node, {
      x: node.scrollLeft,
      y: node.scrollTop
    }];
  });
  return function revert() {
    saver.forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          node = _ref2[0],
          _ref2$ = _ref2[1],
          x = _ref2$.x,
          y = _ref2$.y;

      node.scrollLeft = x;
      node.scrollTop = y;
    });
  };
}

var body = _get(_globalThis, 'document.body');

var screenScrollingElement = _get(_globalThis, 'document.scrollingElement', _get(_globalThis, 'document.documentElement', {}));

var getErrorTips = function getErrorTips(name) {
  return "<KeepAlive ".concat(name ? "name=\"".concat(name, "\" ") : '', "/> Too many transient updates, may have encountered an infinite loop of updates, forced to pause the update\nThere are serious performance issues with the update results you are currently seeing\nMay encounter an implied bug, please don't use KeepAlive and contact the author to solve");
};

var parseWhenResult = function parseWhenResult(res) {
  if (_isArray(res)) {
    return res;
  }

  return [res];
};

var KeepAlive =
/*#__PURE__*/
function (_Component) {
  _inherits(KeepAlive, _Component);

  // 用作 Keeper 识别 KeepAlive
  // 用作 Keeper 识别 KeepAlive
  function KeepAlive(props) {
    var _this;

    _classCallCheck(this, KeepAlive);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(KeepAlive).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "updateTimes", 0);

    _defineProperty(_assertThisInitialized(_this), "errorTips", _debounce(function () {
      var name = _this.props.name;
      console.error(getErrorTips(name));
    }, 100));

    _defineProperty(_assertThisInitialized(_this), "releaseUpdateTimes", _debounce(function () {
      _this.updateTimes = 0;
    }, 16));

    _defineProperty(_assertThisInitialized(_this), "needForceStopUpdate", function () {
      var needForceStopUpdate = _this.updateTimes > 64;

      if (needForceStopUpdate) {
        _this.errorTips();
      }

      _this.updateTimes++;

      _this.releaseUpdateTimes();

      return needForceStopUpdate;
    });

    _defineProperty(_assertThisInitialized(_this), "id", null);

    _defineProperty(_assertThisInitialized(_this), "isKeepAlive", true);

    _defineProperty(_assertThisInitialized(_this), "cached", false);

    _defineProperty(_assertThisInitialized(_this), "inject", function () {
      var didActivate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var _this$props = _this.props,
          id = _this$props.id,
          saveScrollPosition = _this$props.saveScrollPosition,
          _helpers = _this$props._helpers;

      var cache = _helpers.getCache(id); // DOM 操作有风险，try catch 护体


      try {
        // // 原计划不增加额外的节点，直接将 Keeper 中所有内容节点一一迁移
        // // 后发现缺乏统一 react 认可的外层包裹，可能会造成 react dom 操作的错误
        // // 且将导致 KeepAlive 进行 update 时需先恢复各 dom 节点的组件归属，成本过高
        // // 故此处增加统一的 div 外层，Keeper 中与 KeepAlive 中各一个且外层不做移除处理
        // this.parentNode = this.placeholder.parentNode
        // cache.nodes.forEach(node => {
        //   this.parentNode.insertBefore(node, this.placeholder)
        // })
        // this.parentNode.removeChild(this.placeholder)
        // 将 AliveScopeProvider 中的渲染内容通过 dom 操作置回当前 KeepAlive
        cache.nodes.forEach(function (node) {
          _this.placeholder.appendChild(node);
        });

        if (didActivate && saveScrollPosition) {
          // 恢复该节点下各可滚动元素的滚动位置
          _run(cache.revertScrollPos);
        }
      } catch (error) {// console.error(error)
      }
    });

    _defineProperty(_assertThisInitialized(_this), "eject", function () {
      var willUnactivate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var _this$props2 = _this.props,
          id = _this$props2.id,
          _helpers = _this$props2._helpers;

      var cache = _helpers.getCache(id);

      var nodesNeedToSaveScrollPosition = _flatten(_flatten([_this.props.saveScrollPosition]).map(function (flag) {
        if (flag === true) {
          return cache.nodes;
        }

        if (flag === 'screen') {
          return [screenScrollingElement, body];
        }

        return _toConsumableArray(_value(_run(_globalThis, 'document.querySelectorAll', flag), []));
      })).filter(Boolean); // DOM 操作有风险，try catch 护体


      try {
        if (willUnactivate && nodesNeedToSaveScrollPosition.length > 0) {
          // 保存该节点下各可滚动元素的滚动位置
          cache.revertScrollPos = saveScrollPosition(nodesNeedToSaveScrollPosition);
        } // // 原计划不增加额外的节点，直接将 Keeper 中所有内容节点一一迁移
        // // 后发现缺乏统一 react 认可的外层包裹，可能会造成 react dom 操作的错误
        // // 且将导致 KeepAlive 进行 update 时需先恢复各 dom 节点的组件归属，成本过高
        // // 故此处增加统一的 div 外层，Keeper 中与 KeepAlive 中各一个且外层不做移除处理
        // this.parentNode.insertBefore(this.placeholder, cache.nodes[0])
        // cache.nodes.forEach(node => {
        //   if (willUnactivate) {
        //     this.parentNode.removeChild(node)
        //   } else {
        //     cache.wrapper.appendChild(node)
        //   }
        // })
        // this.parentNode.insertBefore(this.placeholder, cache.nodes[0])
        // 将 KeepAlive 中的节点恢复为原先的占位节点，保证卸载操作正常进行


        cache.nodes.forEach(function (node) {
          if (willUnactivate) {
            _this.placeholder.removeChild(node);
          } else {
            cache.wrapper.appendChild(node);
          }
        });
      } catch (error) {// console.error(error)
      }
    });

    _defineProperty(_assertThisInitialized(_this), "init", function () {
      var _this$props3 = _this.props,
          _helpers = _this$props3._helpers,
          id = _this$props3.id,
          children = _this$props3.children,
          rest = _objectWithoutProperties(_this$props3, ["_helpers", "id", "children"]); // 将 children 渲染至 AliveScopeProvider 中


      _helpers.keep(id, _objectSpread2({
        children: children,
        getInstance: function getInstance() {
          return _assertThisInitialized(_this);
        }
      }, rest)).then(function (cache) {
        // fix #22
        if (!cache) {
          return;
        }

        _this.inject(); // 触发 didActivate 生命周期


        if (cache.inited) {
          _run(_assertThisInitialized(_this), LIFECYCLE_ACTIVATE);
        } else {
          cache.inited = true;
        }

        _this.cached = false;
      });
    });

    _defineProperty(_assertThisInitialized(_this), "update", function () {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _helpers = _ref._helpers,
          id = _ref.id,
          name = _ref.name,
          rest = _objectWithoutProperties(_ref, ["_helpers", "id", "name"]);

      if (!_helpers || _this.cached || _this.needForceStopUpdate(name)) {
        return;
      } // // 原先打算更新过程中先重置 dom 节点状态，更新后恢复 dom 节点
      // // 但考虑到性能消耗可能过大，且可能因 dom 操作时机引发其他 react 渲染问题，故不使用
      // // 对应 Keeper 处 componentDidUpdate 也注释起来不使用
      // this.eject(false)


      _helpers.update(id, _objectSpread2({
        name: name,
        getInstance: function getInstance() {
          return _assertThisInitialized(_this);
        }
      }, rest)); // this.inject(false)

    });

    _this.id = props.id;

    _this.init() // 继承响应父级 KeepAlive 的生命周期
    ;

    [LIFECYCLE_ACTIVATE, LIFECYCLE_UNACTIVATE].forEach(function (lifecycleName) {
      _this[lifecycleName] = function () {
        var _this$props4 = _this.props,
            id = _this$props4.id,
            _helpers = _this$props4._helpers;

        var cache = _helpers.getCache(id);

        var node = _helpers.getNode(id);

        if (node && lifecycleName == LIFECYCLE_ACTIVATE) {
          node.updateTime = Date.now();
        }

        var cached = lifecycleName === LIFECYCLE_UNACTIVATE; // 若组件即将卸载则不再触发缓存生命周期

        if (!cache || cache.willDrop) {
          // 若组件在父 KeepAlive 缓存期间被卸载，后续恢复后需重新触发 init
          if (_this.cached && !cached) {
            _this.init();
          }

          return;
        }

        _run(cache, lifecycleName);

        cache.cached = cached;
        _this.cached = cached;
      };
    });
    return _this;
  } // DOM 操作将实际内容插入占位元素


  _createClass(KeepAlive, [{
    key: "shouldComponentUpdate",
    // 利用 shouldComponentUpdate 提前触发组件更新
    value: function shouldComponentUpdate(nextProps) {
      this.update(nextProps);
      return false;
    } // 组件卸载时重置 dom 状态，保证 react dom 操作正常进行，并触发 unactivate 生命周期

  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this$props5 = this.props,
          id = _this$props5.id,
          _helpers = _this$props5._helpers,
          _this$props5$when = _this$props5.when,
          calcWhen = _this$props5$when === void 0 ? true : _this$props5$when;

      var cache = _helpers.getCache(id);

      var _parseWhenResult = parseWhenResult(_run(calcWhen)),
          _parseWhenResult2 = _slicedToArray(_parseWhenResult, 2),
          when = _parseWhenResult2[0],
          isScope = _parseWhenResult2[1];

      if (!cache) {
        return;
      }

      this.eject();
      delete cache.getInstance;

      if (!when) {
        if (isScope) {
          var needToDrop = [cache].concat(_toConsumableArray(_helpers.getScopeIds([id]).map(function (id) {
            return _helpers.getCache(id);
          })));
          needToDrop.forEach(function (cache) {
            cache.willDrop = true;
          });

          _nextTick(function () {
            return _helpers.dropScopeByIds([id]);
          });
        } else {
          cache.willDrop = true;

          _nextTick(function () {
            return _helpers.dropById(id);
          });
        }
      } // 触发 willUnactivate 生命周期


      _run(this, LIFECYCLE_UNACTIVATE);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      return React__default.createElement("div", {
        key: "keep-alive-placeholder",
        className: "ka-wrapper",
        ref: function ref(node) {
          _this2.placeholder = node;
        }
      });
    }
  }]);

  return KeepAlive;
}(React.Component); // 兼容 SSR 服务端渲染


_defineProperty(KeepAlive, "defaultProps", {
  saveScrollPosition: true
});

function SSRKeepAlive(_ref2) {
  var children = _ref2.children;
  return React__default.createElement("div", {
    key: "keep-alive-placeholder",
    className: "ka-wrapper"
  }, React__default.createElement("div", {
    key: "keeper-container",
    className: "ka-content"
  }, children));
}

var KeepAlive$1 = _isFunction(_get(_globalThis, 'document.getElementById')) ? expandKeepAlive(withActivation(KeepAlive)) : SSRKeepAlive;

exports.AliveScope = AliveScope;
exports.KeepAlive = KeepAlive$1;
exports.NodeKey = NodeKey;
exports.createContext = createContext;
exports.default = KeepAlive$1;
exports.fixContext = fixContext;
exports.useActivate = useActivate;
exports.useAliveController = useAliveController;
exports.useUnactivate = useUnactivate;
exports.withActivation = withActivation;
exports.withAliveScope = withAliveScope;
//# sourceMappingURL=index.js.map
