{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar _run = _interopDefault(require('szfe-tools/lib/run'));\n\nvar react = require('react');\n\nvar _isFunction = _interopDefault(require('szfe-tools/lib/isFunction'));\n\nvar _isString = _interopDefault(require('szfe-tools/lib/isString'));\n\nvar _get = _interopDefault(require('szfe-tools/lib/get'));\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction getKey2Id() {\n  var uuid = 0;\n  var map = new Map(); // 对每种 NodeType 做编号处理\n\n  return function key2Id(key) {\n    var id = map.get(key);\n\n    if (!id) {\n      id = (++uuid).toString(32);\n      map.set(key, id);\n    }\n\n    return id;\n  };\n}\n\nvar isArrReg = /^iAr/; // 对每种 NodeType 做编号处理\n\nvar key2Id = getKey2Id(); // 获取节点的渲染路径，作为节点的 X 坐标\n\nvar genRenderPath = function genRenderPath(node) {\n  return node[\"return\"] ? [node].concat(_toConsumableArray(genRenderPath(node[\"return\"]))) : [node];\n}; // 使用节点 _nk 属性或下标与其 key/index 作为 Y 坐标\n\n\nvar getNodeId = function getNodeId(fiberNode) {\n  // FIXME: 使用 index 作为 Y 坐标是十分不可靠的行为，待想出更好的法子替代\n  var id = _get(fiberNode, 'key') || fiberNode.index;\n\n  var nodeKey = _get(fiberNode, 'pendingProps._nk');\n\n  var isArray = _isString(nodeKey) && isArrReg.test(nodeKey);\n  return isArray ? \"\".concat(nodeKey, \".\").concat(id) : nodeKey || id;\n};\n\nvar markNode = function markNode(node) {\n  var x = key2Id(_get(node, 'type.$$typeof', node.type));\n  var y = getNodeId(node);\n  return \"\".concat(x, \",\").concat(y);\n}; // 根据 X,Y 坐标生成 Key\n\n\nvar getKeyByCoord = function getKeyByCoord(nodes, handleNode) {\n  return nodes.map(function (node) {\n    var mark = markNode(node);\n    return _isFunction(handleNode) ? _run(handleNode, undefined, node, mark) : mark;\n  }).filter(Boolean).join('|');\n};\n\nvar getKeyByFiberNode = function getKeyByFiberNode(fiberNode, handleNode) {\n  var key = getKeyByCoord(genRenderPath(fiberNode), handleNode);\n  return key2Id(key);\n};\n\nvar isArrReg$1 = /^iAr/; // 对每种 NodeType 做编号处理\n\nvar key2Id$1 = getKey2Id(); // 获取节点的渲染路径，作为节点的 X 坐标\n\nvar genRenderPath$1 = function genRenderPath(node) {\n  return node.__ ? [node].concat(_toConsumableArray(genRenderPath(node.__))) : [node];\n}; // 使用节点 _nk 属性或下标与其 key/index 作为 Y 坐标\n\n\nvar getNodeId$1 = function getNodeId(node) {\n  // FIXME: Preact 无 index 属性，无 key 与 _nk 之下 Y 坐标不可靠，待修正\n  var id = _get(node, 'key') || node.index;\n\n  var nodeKey = _get(node, 'props._nk');\n\n  var isArray = _isString(nodeKey) && isArrReg$1.test(nodeKey);\n  return isArray ? \"\".concat(nodeKey, \".\").concat(id) : nodeKey || id;\n};\n\nvar markNode$1 = function markNode(node) {\n  var x = key2Id$1(node.type);\n  var y = getNodeId$1(node);\n  return \"\".concat(x, \",\").concat(y);\n}; // 根据 X,Y 坐标生成 Key\n\n\nvar getKeyByCoord$1 = function getKeyByCoord(nodes, handleNode) {\n  return nodes.map(function (node) {\n    var mark = markNode$1(node);\n    return _isFunction(handleNode) ? _run(handleNode, undefined, node, mark) : mark;\n  }).filter(Boolean).join('|');\n};\n\nvar getKeyByNode = function getKeyByNode(node, handleNode) {\n  var key = getKeyByCoord$1(genRenderPath$1(node), handleNode);\n  return key2Id$1(key);\n};\n\nvar type; // 根据 FiberNode 所处位置来确定 nodeKey\n\nvar NodeKey = /*#__PURE__*/function (_Component) {\n  _inherits(NodeKey, _Component);\n\n  var _super = _createSuper(NodeKey);\n\n  function NodeKey() {\n    var _this;\n\n    _classCallCheck(this, NodeKey);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"key\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"genKey\", function (onHandleNode) {\n      if (!type) {\n        // _reactInternals 为 React v17 fiberNode 节点字段\n        if (_this._reactInternalFiber || _this._reactInternals) {\n          type = 'React';\n        } // TODO: May \"preact/compat\" mode only, not verified yet.\n\n\n        if (_this.__v) {\n          type = 'Preact';\n        }\n      }\n\n      switch (type) {\n        case 'Preact':\n          {\n            _this.key = getKeyByNode(_this.__v, onHandleNode);\n            break;\n          }\n\n        case 'React':\n          {\n            var fiberNode = _this._reactInternalFiber || _this._reactInternals;\n            _this.key = getKeyByFiberNode(fiberNode, onHandleNode);\n            break;\n          }\n      }\n\n      return _this.key;\n    });\n\n    return _this;\n  }\n\n  _createClass(NodeKey, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          prefix = _this$props.prefix,\n          onHandleNode = _this$props.onHandleNode;\n      return _run(children, undefined, \"\".concat(prefix).concat(this.key || this.genKey(onHandleNode)));\n    }\n  }]);\n\n  return NodeKey;\n}(react.Component);\n\n_defineProperty(NodeKey, \"defaultProps\", {\n  onHandleNode: undefined,\n  prefix: ''\n});\n\nexports.default = NodeKey;","map":{"version":3,"sources":["../src/helpers/index.js","../src/core/NodeKey/getKeyByFiberNode.js","../src/core/NodeKey/getKeyByPreactNode.js","../src/core/NodeKey/index.js"],"names":["uuid","map","id","isArrReg","key2Id","getKey2Id","genRenderPath","node","getNodeId","fiberNode","nodeKey","isArray","markNode","x","y","getKeyByCoord","mark","getKeyByFiberNode","key","getKeyByNode","NodeKey","Component","onHandleNode","prefix","type","getKeyByPreactNode","children"],"mappings":"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","sourcesContent":["export function getKey2Id() {\n  let uuid = 0\n  const map = new Map()\n\n  // 对每种 NodeType 做编号处理\n  return function key2Id(key) {\n    let id = map.get(key)\n\n    if (!id) {\n      id = (++uuid).toString(32)\n      map.set(key, id)\n    }\n\n    return id\n  }\n}\n","import { isString, isFunction, get, run } from 'szfe-tools'\n\nimport { getKey2Id } from '../../helpers'\n\nconst isArrReg = /^iAr/\n\n// 对每种 NodeType 做编号处理\nconst key2Id = getKey2Id()\n\n// 获取节点的渲染路径，作为节点的 X 坐标\nconst genRenderPath = (node) =>\n  node.return ? [node, ...genRenderPath(node.return)] : [node]\n\n// 使用节点 _nk 属性或下标与其 key/index 作为 Y 坐标\nconst getNodeId = (fiberNode) => {\n  // FIXME: 使用 index 作为 Y 坐标是十分不可靠的行为，待想出更好的法子替代\n  const id = get(fiberNode, 'key') || fiberNode.index\n  const nodeKey = get(fiberNode, 'pendingProps._nk')\n  const isArray = isString(nodeKey) && isArrReg.test(nodeKey)\n\n  return isArray ? `${nodeKey}.${id}` : nodeKey || id\n}\n\nconst markNode = (node) => {\n  const x = key2Id(get(node, 'type.$$typeof', node.type))\n  const y = getNodeId(node)\n\n  return `${x},${y}`\n}\n\n// 根据 X,Y 坐标生成 Key\nconst getKeyByCoord = (nodes, handleNode) =>\n  nodes\n    .map((node) => {\n      const mark = markNode(node)\n\n      return isFunction(handleNode)\n        ? run(handleNode, undefined, node, mark)\n        : mark\n    })\n    .filter(Boolean)\n    .join('|')\n\nconst getKeyByFiberNode = (fiberNode, handleNode) => {\n  const key = getKeyByCoord(genRenderPath(fiberNode), handleNode)\n\n  return key2Id(key)\n}\n\nexport default getKeyByFiberNode\n","import { isString, isFunction, get, run } from 'szfe-tools'\n\nimport { getKey2Id } from '../../helpers'\n\nconst isArrReg = /^iAr/\n\n// 对每种 NodeType 做编号处理\nconst key2Id = getKey2Id()\n\n// 获取节点的渲染路径，作为节点的 X 坐标\nconst genRenderPath = (node) =>\n  node.__ ? [node, ...genRenderPath(node.__)] : [node]\n\n// 使用节点 _nk 属性或下标与其 key/index 作为 Y 坐标\nconst getNodeId = (node) => {\n  // FIXME: Preact 无 index 属性，无 key 与 _nk 之下 Y 坐标不可靠，待修正\n  const id = get(node, 'key') || node.index\n  const nodeKey = get(node, 'props._nk')\n  const isArray = isString(nodeKey) && isArrReg.test(nodeKey)\n\n  return isArray ? `${nodeKey}.${id}` : nodeKey || id\n}\n\nconst markNode = (node) => {\n  const x = key2Id(node.type)\n  const y = getNodeId(node)\n\n  return `${x},${y}`\n}\n\n// 根据 X,Y 坐标生成 Key\nconst getKeyByCoord = (nodes, handleNode) =>\n  nodes\n    .map((node) => {\n      const mark = markNode(node)\n\n      return isFunction(handleNode)\n        ? run(handleNode, undefined, node, mark)\n        : mark\n    })\n    .filter(Boolean)\n    .join('|')\n\nconst getKeyByNode = (node, handleNode) => {\n  const key = getKeyByCoord(genRenderPath(node), handleNode)\n\n  return key2Id(key)\n}\n\nexport default getKeyByNode\n","import { Component } from 'react'\nimport { run } from 'szfe-tools'\n\nimport getKeyByFiberNode from './getKeyByFiberNode'\nimport getKeyByPreactNode from './getKeyByPreactNode'\n\nlet type\n\n// 根据 FiberNode 所处位置来确定 nodeKey\nexport default class NodeKey extends Component {\n  static defaultProps = {\n    onHandleNode: undefined,\n    prefix: '',\n  }\n\n  key = null\n  genKey = (onHandleNode) => {\n    if (!type) {\n      // _reactInternals 为 React v17 fiberNode 节点字段\n      if (this._reactInternalFiber || this._reactInternals) {\n        type = 'React'\n      }\n\n      // TODO: May \"preact/compat\" mode only, not verified yet.\n      if (this.__v) {\n        type = 'Preact'\n      }\n    }\n\n    switch (type) {\n      case 'Preact': {\n        this.key = getKeyByPreactNode(this.__v, onHandleNode)\n        break\n      }\n      case 'React': {\n        const fiberNode = this._reactInternalFiber || this._reactInternals\n        this.key = getKeyByFiberNode(fiberNode, onHandleNode)\n        break\n      }\n      default: {\n        break\n      }\n    }\n\n    return this.key\n  }\n\n  render() {\n    const { children, prefix, onHandleNode } = this.props\n\n    return run(\n      children,\n      undefined,\n      `${prefix}${this.key || this.genKey(onHandleNode)}`\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}